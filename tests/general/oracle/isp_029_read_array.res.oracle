[kernel] Parsing isp_029_read_array.c (with preprocessing)
[isp] No entry point was specified! The default entry point "main" will be used.
[isp] Execute Eva with entry point "main"
[eva] Analyzing an incomplete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  STATE[0..1] ∈ [--..--]
  DB[0..1] ∈ [--..--]
[eva:alarm] isp_029_read_array.c:23: Warning: 
  function main, behavior interface_spec: precondition STATE[0] ∈ (0 .. 400) got status unknown.
[eva:alarm] isp_029_read_array.c:24: Warning: 
  function main, behavior interface_spec: precondition STATE[1] ∈ (0 .. 9000) got status unknown.
[eva:alarm] isp_029_read_array.c:25: Warning: 
  function main, behavior interface_spec: precondition DB[RPM] ∈ (0 .. 9000) got status unknown.
[eva:alarm] isp_029_read_array.c:26: Warning: 
  function main, behavior interface_spec: precondition DB[SPEED] ∈
                                                       (0 .. 9000) got status unknown.
[eva] done for function main
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 3): 100% coverage.
  In these functions, 9 statements reached (out of 9): 100% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  0 alarms generated by the analysis.
  ----------------------------------------------------------------------------
  No logical properties have been reached by the analysis.
  ----------------------------------------------------------------------------
[isp] Eva analysis is completed.
[isp] Warning: Arguments of Enum type (VEHICLE_STATE) are not implemented!
[isp] The transformed source code:
/* Generated by Frama-C */
enum __anonenum_VEHICLE_STATE_1 {
    RPM = 0,
    SPEED = 1
};
typedef enum __anonenum_VEHICLE_STATE_1 VEHICLE_STATE;
int STATE[2];
int DB[2];
/*@ requires STATE[1] ≥ 0;
    requires STATE[1] ≤ 9000;
    requires STATE[0] ≥ 0;
    requires STATE[0] ≤ 400;
    requires \valid_read(&STATE[1]);
    requires \valid_read((int *)STATE);
    ensures \result ≥ 0;
    ensures \result ≤ 9000;
    assigns \nothing;
 */
int read_state(int idx)
{
  int __retres;
  __retres = STATE[idx];
  return __retres;
}

/*@ requires DB[1] ≥ 0;
    requires DB[1] ≤ 9000;
    requires DB[0] ≥ 0;
    requires DB[0] ≤ 9000;
    requires \valid_read(&DB[1]);
    requires \valid_read((int *)DB);
    ensures \result ≥ 0;
    ensures \result ≤ 9000;
    assigns \nothing;
 */
int read_db(VEHICLE_STATE s)
{
  int __retres;
  __retres = DB[s];
  return __retres;
}

/*@ requires STATE[1] ≥ 0;
    requires STATE[1] ≤ 9000;
    requires DB[1] ≥ 0;
    requires DB[1] ≤ 9000;
    requires STATE[0] ≥ 0;
    requires STATE[0] ≤ 400;
    requires DB[0] ≥ 0;
    requires DB[0] ≤ 9000;
    requires \valid_read(&STATE[1]);
    requires \valid_read(&DB[1]);
    requires \valid_read((int *)STATE);
    requires \valid_read((int *)DB);
    assigns \nothing;
    
    behavior interface_spec:
      assumes \true;
      requires \valid_read(&STATE[0 .. 1]);
      requires \valid_read(&DB[0 .. 1]);
      requires STATE[0] ∈ (0 .. 400);
      requires STATE[1] ∈ (0 .. 9000);
      requires DB[RPM] ∈ (0 .. 9000);
      requires DB[SPEED] ∈ (0 .. 9000);
      assigns \nothing;
 */
void main(void)
{
  read_state(1);
  read_state(0);
  read_db(RPM);
  read_db(SPEED);
  return;
}


