## FIT

Note that this plugin is in an experimental state.

## PURPOSE

Semantic inference of auxiliary annotations in Frama-C. Frama-C is a software suite for analysis of C code. Importantly, Frama-C offers powerful value analysis and weakest precondition plugins over C source code. 

The purpose of this Frama-C plugin is to automatically provide contract components for interacting with the WP plugin of Frama-C.

## INSTALL

0. Install dependencies*
1. make
2. Use with -load-module top/Auto or use files in ./scripts
3. ^ Optional : make tests

*Dependencies may include frama-c, why3.

An example that was used to install a previous version of Frama-C using opam:

$ opam switch create 4.12.0 4.12.0\
$ eval $(opam env)\
$ opam install frama-c=23.1\
$ opam install  why3 alt-ergo

An alternative is to use the version of Frama-C in your distributions repository.
For Ubuntu/Debian, the following might work:

$ sudo apt install frama-c-base

We use OCaml 4.12.0  and Frama-C 23.1.  Later versions of Frama-C may require rewriting some code to support updated API.

## USE

Annotate your program with ACSL postconditions / ensures clauses. Then our plugin creates auxiliary requires and assigns clauses.
There is limited support for also inferring some ensures clauses.

Examples of use cases can be found in the ./scripts directory, e.g. the following will annotate the program then attempt to prove the resulting annotations:

frama-c -Auto-debug 0 -rte -lib-entry -load-module top/Auto  [c source file] -main [main function name] -then  -wp -wp-prover "why3:cvc4"

Other use cases are found in the scripts/ folder in the frama-c/src/plugins/aa directory:

scripts/
auto.sh  prove.sh  transform.sh

transform.sh outputs a file with the annotated code, auto.sh corresponds to the above command, and prove will use some sensible default parameters for initializing wp over an annotated output file.

To verify the annotations in the output file, you can for instance type frama-c -wp out.c -wp-prover native:alt-ergo.

Explanation:

-Auto-debug : set debug print level\
-rte : pre-process file with RTE plugin to place intermediate run-time assertions in source code\
-lib-entry : less assumptions on memory initialization - see Frama-C user manual\
-load-module top/Auto : load the compiled plugin (inside the top directory by default) to analyze and annotate the source project\
-main : set project entry point\
-then -wp : after running the previous analysis, use the wp plugin to verify annotations in the generated source\
-wp-prover : set the proving engine. -wp-prover native:alt-ergo   might work without installing external dependencies.

Our plugin contains the following flags

-(no-)show-origin : (do not) display the origin of each contract component\
-(no-)assigns : (do not) generate assigns annotations\
-(no-)requires : (do not) generate requires annotations\
-(no-)requires-rte : (do not) generate requires annotations from intermediate RTE assertions\
-(no-)ensures : (do not) generate ensures annotations\
-(no-)l : (do not) generate loop assigns and loop invariants\
-(no-)main-assigns-any : (do not) generate assigns clauses for main function\
-(no-)annot-main : (do not) generate (any/)all annotations for main function\
-(no-)depsv : (do not) use deps visitor to generate assigns and requires clauses\
-(no-)propscope : (do not) use the Frama-C Prop Scope plugin to lift intermediate assertions to contract\
  
Other useful flags include

-kernel-warn-key annot-error=active (debugging annotations)

 
### Use example
  
We provide an example of using our plugin.
  
We will analyze the multiarrays.c file inside the ./data folder.
  
```
  
int d[1][2][10000][4];
int test;

int main() {
  for (int i = 1; i < 9999; i += 1)
    d[0][1][i][3] = 10;
  return 0;                          
}
                           
```
  
  
This file can be automatically annotated as follows. Run the transform.sh script:
  
./scripts/transform.sh data/multiarrays.c main

The output might look like the following
                           
```
                           
/* Generated by Frama-C */
int d[1][2][10000][4];
int test;
/*@ ensures \result ≤ (int)0;
    ensures \result ≥ (int)0;
    assigns d[(int)0][(int)1][(int)1][(int)3],
            d[(int)0][(int)1][(int)2 .. (int)9998][(int)0 .. (int)3];
    
    behavior infer_ensures:
      assumes \false;
      ensures \result ≤ (int)0;
      ensures \result ≥ (int)0;
    
    behavior Deps:
      assumes \false;
      assigns d[(int)0][(int)1][(int)1][(int)3],
              d[(int)0][(int)1][(int)2 .. (int)9998][(int)0 .. (int)3];
 */
int main(void)
{
  int __retres;
  {
    int i = 1;
    while (i < 9999) {
      /*@ assert rte: index_bound: 0 ≤ i; */
      /*@ assert rte: index_bound: i < 10000; */
      d[0][1][i][3] = 10;
      /*@ assert rte: signed_overflow: i + 1 ≤ 2147483647; */
      i ++;
    }
  }
  __retres = 0;
  return __retres;
}

```

#### Explanation

```
ensures \result ≤ (int)0;
ensures \result ≥ (int)0;
```                                             
The value analysis plugin of Frama-C correctly deduces that the return value of the given function is zero, whereupon our plugin provides this as a post-condition in the generated function contract.

```
assigns d[(int)0][(int)1][(int)1][(int)3],
d[(int)0][(int)1][(int)2 .. (int)9998][(int)0 .. (int)3];

```
Similalarly, the deps plugin of Frama-C infers the potentially assigned memory addresses of the test function. Our plugin adds these memory addresses to the contract.

```
    behavior infer_ensures:
      assumes \false;
      ensures \result ≤ (int)0;
      ensures \result ≥ (int)0;
```
                                             
(This information is only output if the show-origin option is toggled) Also provided is a dummy behavior for each visitor that aided in the analysis, showing from which visitor the output annotations originate.
                                             
## Repository navigation

./data : contains test data for our plugin\
./docs : attaches documentation for Frama-C\
./frama-c/src/plugins/aa : the source code folder\
./report : Thesis, contains details on plugin\
./tutorial : Examples of simple Frama-C visitors\

### Source code navigation

Inside ./frama-c/src/plugins/aa, the following files may be found:

development : old versions of source code files that might be worth referencing or using later\
scripts : easy-of-use scripts for generating annotated code and possibly testing it using WP\
tests : non-regression tests\
Auto.mli : dummy file necessary for compilation\
Makefile : makefile\
README.md : readme\
generalize.ml : helper functions for visitor_assigns\
option.ml : file for defining command line options (given in the use section above)\
preliminariesA.ml : pure OCaml methods\
preliminariesB.ml : general Frama-C methods\
propagation.ml : methods for propagating expressions between different functions, taking into account potentially out of scope local variables\
visit.ml : main file executing the below visitors, which are all described above in the use section.\
visitor_assigns.ml\
visitor_deps.ml\
visitor_infer_ensures.ml\
visitor_postprocess.ml\
visitor_prop_scope.ml\
visitor_push_rte.ml\
visitor_requires.ml \
loops_visitor.ml\
  
## DEVELOP

#### Tooling
At the time of writing, we suggest Merlin and VSCode for autocompletion and referencing documentation.
Consider placing the plugin directory in the src folder of Frama-C, to interact nicely with Merlin.
At the time of writing, the OCaml and Reason IDE extension for VSCode is our choice for 
Merlin integration (a user proficient in Emacs or VIM may also find corresponding extensions
for such IDE). Developing in Frama-C without Merlin is not recommended.

#### Documtentation
There are plenty of implementation references in the frama-c kernel and services folders, and
among Frama-C's plugins, e.g. files in src/plugins/ in the default distribution.

The internal documentation, distributed with Frama-C and available online at 
https://arvidj.eu/frama-c/latest/html/index.html
is also a good resource.

It is not unlikely that the developer will have to look for references directly in the 
Frama-C source. Both kernel code and plugin code (in src/kernel_ and src/plugins respectively)
will likely serve as useful references.
  
Our own plugin might also serve as example of Frama-C development. Each significant method in our
source code is documented in comments. The tutorial section of this repository contains many smaller
examples of visitors that might aid a developer new to Frama-C.

A good example of a first visitor can be found in the Frama-C Developer's Manual, 
and is also supplied with this repository in the tutorial folder, at the
tutorial/ContractGenerationHelloWorld/VisitorAnnotater.ml path.
  
### TESTING

In the main folder, type 

ptests.opt 

To test updates against the oracle.
                                             
To show output, type ptests.opt -show.

To accept changes in output and provide a new oracle from latest output, or provide a starting reference for non-regression testing,
type ptests.opt -update.

To show all options for ptests, type ptests.opt -help
                                             
### THEORY

We perform semantic annotation of a program. We provide requires clauses and assigns clauses. Requires clauses are 
synthesized from possible run-time exceptions, where the EVA plugin provides semantic discharging of always true preconditions.

Our method is based on the value analysis of Frama-C, which can bound the possible values of program variables at different program points. In this way we can proceed to deduce necessary pre-conditions to prevent run-time errors in a program, bound the return values of functions, and realize a memory model specification for a program automatically. Various heuristics are used and several approaches are tried, each realized as a separate Frama-C visitor.
